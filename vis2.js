// Generated by CoffeeScript 1.7.1

/*

LEVEL 1B: Parallel Coordinates Visualization

The software tool at this level should be able to display the tabular data in the spreadsheet named
as “5-years” in FreqWords.xlsx using a parallel coordinates plot. The table includes 5 major data
columns, labelled as “1990-1994”, “1995-1999”, ..., “2000-2014”. Each column has 40 measured
values, that is, 40 multivariate data objects (with five variables). In addition to the five numerical
values, each data object is associated with a nominal value, representing a frequently-occurred
word.

Your software must have the following essential functionality:

 - Display a line for each of the k (20  k  40) data objects, intersecting with the 6 axes at correct places.
 If you choose k < 40, it is recommended to use the k words with more frequent occurrence.
 - Display labels for each axis.
 - Provide a brushing utility. (Vertical brushing on all)
 - It is recommended to set all five numerical axes to the range [0, 250]. However, you may experiment
 with other ranges for these axes.
 */
var AXIS_NAMES, COLOUR_SCALE, HEIGHT, HORIZONTAL_SCALE, NUMBER_COLUMNS, WIDTH, YEAR_COLUMNS, drawBrushesAndAxes, drawPathsOntoSvg, drawTextLabels, g, makeBrushes, makeSvgGroup, mouseOverLineCallback, transformData;

YEAR_COLUMNS = ['1990-1994', '1995-1999', '2000-2004', '2005-2009', '2010-2014'];

NUMBER_COLUMNS = YEAR_COLUMNS.concat('sum');

AXIS_NAMES = YEAR_COLUMNS.concat(['word']);

WIDTH = 600;

HEIGHT = 600;

HORIZONTAL_SCALE = d3.scale.linear().domain([0, 5]).range([0, WIDTH - 20]);

COLOUR_SCALE = d3.scale.category20b().domain([250, 0]);

makeSvgGroup = function() {
  return d3.select('#visualisation2').style({
    width: WIDTH + 200,
    height: HEIGHT + 200,
    background: '#444'
  }).append('g').attr({
    'transform': 'translate(70,100)'
  });
};

transformData = function(rows, verticalScales) {
  return rows.map(function(row) {
    return {
      coordinates: d3.zip(verticalScales, AXIS_NAMES).map(function(_arg, i) {
        var colName, scale;
        scale = _arg[0], colName = _arg[1];
        return {
          x: HORIZONTAL_SCALE(i),
          y: scale(row[colName])
        };
      }),
      sum: row.sum,
      word: row.word
    };
  });
};

mouseOverLineCallback = function(g, transformedData) {
  return function(mouseOverRow) {
    var circles, lineColour;
    lineColour = 'black';
    circles = g.selectAll('circle.line-highlight').data(mouseOverRow.coordinates);
    circles.enter().append('circle').attr({
      'class': 'line-highlight',
      'r': 3,
      'stroke': lineColour,
      'stroke-width': 2
    });
    circles.attr({
      cx: function(point) {
        return point.x;
      },
      cy: function(point) {
        return point.y;
      }
    });
    return g.selectAll('path.line').data(transformedData).attr({
      'stroke': function(row) {
        return COLOUR_SCALE(row.coordinates[4].y);
      }
    }).filter(function(row) {
      return row === mouseOverRow;
    }).attr({
      'stroke': lineColour
    });
  };
};

drawPathsOntoSvg = function(g, transformedData) {
  return g.selectAll('path').data(transformedData).enter().append('path').attr({
    'title': function(row) {
      return row.word;
    },
    'class': 'line',
    'd': function(row) {
      return (d3.svg.line().interpolate('cardinal').tension(0.8).x(function(point) {
        return point.x;
      }).y(function(point) {
        return point.y;
      }))(row.coordinates);
    },
    'stroke': function(row) {
      return COLOUR_SCALE(row.coordinates[4].y);
    },
    'stroke-width': 1.8,
    'fill': 'none'
  }).on('mouseover', mouseOverLineCallback(g, transformedData));
};

makeBrushes = function(g, verticalScales) {
  var brush, brushes, focusLines, rowMatchesAllBrushes, _i, _len;
  brushes = verticalScales.map(function(scale) {
    return d3.svg.brush().y(scale);
  });
  rowMatchesAllBrushes = function(row) {
    return d3.zip(row.coordinates, verticalScales, brushes).filter(function(_arg) {
      var brush, data, scale;
      data = _arg[0], scale = _arg[1], brush = _arg[2];
      return !brush.empty();
    }).every(function(_arg) {
      var brush, data, lower, scale, transform, upper, _ref, _ref1;
      data = _arg[0], scale = _arg[1], brush = _arg[2];
      _ref = brush.extent(), lower = _ref[0], upper = _ref[1];
      transform = scale.invert != null ? scale.invert : function(x) {
        return x;
      };
      return (lower <= (_ref1 = transform(data.y)) && _ref1 <= upper);
    });
  };
  focusLines = function() {
    return g.selectAll('path.line').attr({
      'opacity': 0.1
    }).filter(rowMatchesAllBrushes).attr({
      'opacity': 0.8
    });
  };
  for (_i = 0, _len = brushes.length; _i < _len; _i++) {
    brush = brushes[_i];
    brush.on('brush', focusLines);
  }
  return brushes;
};

drawBrushesAndAxes = function(g, brushes, axes) {
  return d3.zip(brushes, axes).map(function(_arg, i) {
    var axis, brush;
    brush = _arg[0], axis = _arg[1];
    g.append('g').attr({
      'class': 'vertical-axis',
      'transform': 'translate(' + HORIZONTAL_SCALE(i) + ',0)'
    }).call(axis);
    return g.append('g').call(brush).attr({
      'class': 'brush',
      'transform': 'translate(' + (HORIZONTAL_SCALE(i) - 10) + ',0)',
      'fill': 'rgba(255,0,0,0.2)'
    }).selectAll('rect').attr({
      'width': 40
    });
  });
};

drawTextLabels = function(g) {
  return g.selectAll('text.axis-name').data(AXIS_NAMES).enter().append('text').text(function(name) {
    return name;
  }).style({
    'font-weight': 'bold'
  }).attr({
    'class': 'axis-name',
    'x': function(name, i) {
      return HORIZONTAL_SCALE(i) - 15;
    },
    'y': -30
  });
};

g = makeSvgGroup();

drawTextLabels(g);

d3.csv('FreqWords5Year.csv').row(function(rawRow) {
  NUMBER_COLUMNS.map(function(columnName) {
    return rawRow[columnName] = parseInt(rawRow[columnName], 10);
  });
  return rawRow;
}).get(function(error, rows) {
  var axes, brushes, frequencyScale, transformedData, verticalScales, wordScale;
  frequencyScale = d3.scale.linear().domain([250, 0]).range([0, HEIGHT]);
  wordScale = d3.scale.ordinal().domain(rows.map(function(row) {
    return row.word;
  })).rangePoints([0, HEIGHT]);
  verticalScales = [frequencyScale, frequencyScale, frequencyScale, frequencyScale, frequencyScale, wordScale];
  transformedData = transformData(rows, verticalScales);
  drawPathsOntoSvg(g, transformedData);
  brushes = makeBrushes(g, verticalScales);
  axes = verticalScales.map(function(scale) {
    return d3.svg.axis().scale(scale).orient('right');
  });
  return drawBrushesAndAxes(g, brushes, axes);
});
